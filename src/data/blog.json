[
  {
    "id": 1,
    "title": "Building TaskForge with Next.js and Socket.io — Lessons Learned",
    "excerpt": "Exploring the challenges and solutions in building a real-time collaborative project management platform. From WebSocket connections to optimistic UI updates and conflict resolution.",
    "content": "Building TaskForge was one of my most challenging and rewarding projects. The goal was to create a real-time collaborative project management platform that could handle multiple users working simultaneously without conflicts.\n\nI. The Challenge\n\nReal-time collaboration presents unique technical challenges:\n• WebSocket connection management\n• Optimistic UI updates\n• Conflict resolution when multiple users edit the same item\n• State synchronization across clients\n\nII. The Solution\n\nI chose Next.js 14 with Socket.io for real-time communication and MongoDB for data persistence. The key was implementing a robust state management system with Zustand and handling edge cases gracefully.\n\nIII. Key Learnings\n\n1. Optimistic Updates: Update the UI immediately while sending changes to the server\n2. Conflict Resolution: Implement a last-write-wins strategy with user notifications\n3. Connection Management: Handle reconnections and offline states gracefully\n4. Performance: Use virtual scrolling for large datasets\n\nIV. Results\n\nTaskForge now supports real-time collaboration with sub-second latency and handles up to 100 concurrent users per project. The platform has been used by several teams for project management with positive feedback on the real-time features.",
    "tags": ["Next.js", "Socket.io", "Real-time", "Collaboration", "MongoDB"],
    "date": "2025-01-15",
    "readTime": "8 min read",
    "image": "/assets/projects/taskforge.jpg",
    "author": {
      "name": "Ancel Ajanga",
      "avatar": "/assets/profile-photo.jpg",
      "bio": "Full-stack developer passionate about building scalable web applications"
    }
  },
  {
    "id": 2,
    "title": "Scaling an E-Learning Platform with Django + React",
    "excerpt": "How I built a scalable e-learning platform that handles thousands of students and courses. Covering authentication, course management, and video delivery optimization.",
    "content": "Building a scalable e-learning platform requires careful consideration of architecture, authentication, and content delivery. Here's how I approached this challenge with Django and React.\n\nI. Architecture Decisions\n\nI chose Django REST Framework for the backend due to its robust authentication system and built-in admin interface. React was selected for the frontend to provide a modern, responsive user experience.\n\nII. Key Features Implemented\n\n1. Authentication & Authorization\n   • JWT-based authentication with refresh tokens\n   • Role-based access control (instructors vs students)\n   • Secure password reset and email verification\n\n2. Course Management\n   • Hierarchical course structure (courses → modules → lessons)\n   • File upload handling for course materials\n   • Progress tracking and analytics\n\n3. Video Delivery\n   • Optimized video streaming with adaptive bitrates\n   • Progress tracking for video content\n   • Offline download capabilities\n\nIII. Performance Optimizations\n\n1. Database Optimization: Used select_related and prefetch_related to reduce queries\n2. Caching: Implemented Redis caching for frequently accessed data\n3. CDN: Used AWS CloudFront for static asset delivery\n4. Pagination: Implemented cursor-based pagination for large datasets\n\nIV. Results\n\nThe platform now handles over 10,000 students and 500+ courses with sub-2-second page load times. The system has been stress-tested to handle 1000+ concurrent users.",
    "tags": ["Django", "React", "E-Learning", "Scalability", "Authentication"],
    "date": "2024-12-20",
    "readTime": "10 min read",
    "image": "/assets/projects/elearn.jpg",
    "author": {
      "name": "Ancel Ajanga",
      "avatar": "/assets/profile-photo.jpg",
      "bio": "Full-stack developer passionate about building scalable web applications"
    }
  },
  {
    "id": 3,
    "title": "Why I Built a Finance Tracker in Vue 3",
    "excerpt": "Exploring the decision to use Vue 3 for a personal finance application. Comparing Vue's reactivity system with other frameworks and the benefits for financial data visualization.",
    "content": "When I decided to build a personal finance tracker, I had to choose between React, Angular, and Vue 3. Here's why Vue 3 won and how it shaped the application.\n\nI. Why Vue 3?\n\n1. Composition API\nVue 3's Composition API provides better logic reuse and type safety, which was crucial for financial calculations and data transformations.\n\n2. Reactivity System\nVue's reactivity system is more intuitive for financial data that needs to update in real-time. The automatic dependency tracking made it easier to build reactive charts and calculations.\n\n3. Performance\nVue 3's improved performance with the new virtual DOM implementation was perfect for handling large datasets of financial transactions.\n\nII. Key Features\n\n1. Data Visualization\n• Interactive pie charts showing expense breakdown\n• Line charts for income vs expenses over time\n• Responsive design that works on all devices\n\n2. Data Management\n• Local storage for offline functionality\n• Export capabilities (CSV, PDF)\n• Category management with custom icons\n\n3. User Experience\n• Dark/light mode toggle\n• Smooth animations and transitions\n• Intuitive form validation\n\nIII. Technical Implementation\n\nI used:\n• Vue 3 with Composition API\n• Chart.js for data visualization\n• Tailwind CSS for styling\n• Vite for fast development and building\n• TypeScript for type safety\n\nIV. Results\n\nThe application provides a smooth, responsive experience for tracking personal finances. The Vue 3 architecture made it easy to add new features and maintain the codebase.",
    "tags": ["Vue.js", "Finance", "Data Visualization", "TypeScript", "Chart.js"],
    "date": "2024-11-10",
    "readTime": "6 min read",
    "image": "/assets/projects/finance-tracker.jpg",
    "author": {
      "name": "Ancel Ajanga",
      "avatar": "/assets/profile-photo.jpg",
      "bio": "Full-stack developer passionate about building scalable web applications"
    }
  },
  {
    "id": 4,
    "title": "Angular 20 in Production: The Fitness Class Scheduler Journey",
    "excerpt": "My experience building a fitness class scheduler with Angular 20's new features. Covering SSR, signals, and the improved developer experience.",
    "content": "Angular 20 brought significant improvements to the framework, and I was excited to build a fitness class scheduler to explore these new features in a real-world application.\n\nI. Angular 20 Features Used\n\n1. Server-Side Rendering (SSR)\nAngular 20's improved SSR implementation made it easy to create a fast-loading, SEO-friendly application. The fitness scheduler loads instantly and works great for search engines.\n\n2. Signals\nAngular's new signals API provided a more reactive approach to state management. I used signals for managing class schedules and user preferences.\n\n3. Standalone Components\nBuilding with standalone components simplified the application structure and made it easier to manage dependencies.\n\nII. Application Features\n\n1. Class Management\n• Add, edit, and delete fitness classes\n• Drag-and-drop scheduling interface\n• Recurring class support\n• Instructor assignment\n\n2. User Experience\n• Dark mode with system preference detection\n• Responsive design for all devices\n• Local storage for data persistence\n• Smooth animations and transitions\n\n3. Performance\n• Lazy loading for better initial load times\n• OnPush change detection strategy\n• Optimized bundle size with tree shaking\n\nIII. Technical Stack\n\n• Angular 20 with TypeScript\n• Angular SSR for server-side rendering\n• Tailwind CSS for styling\n• Angular Animations for smooth transitions\n• LocalStorage for data persistence\n\nIV. Results\n\nThe fitness class scheduler provides a smooth, responsive experience with excellent performance scores. Angular 20's new features made development more enjoyable and the application more maintainable.",
    "tags": ["Angular", "SSR", "Signals", "TypeScript", "Fitness"],
    "date": "2024-10-05",
    "readTime": "7 min read",
    "image": "/assets/projects/fitness.jpg",
    "author": {
      "name": "Ancel Ajanga",
      "avatar": "/assets/profile-photo.jpg",
      "bio": "Full-stack developer passionate about building scalable web applications"
    }
  },
  {
    "id": 5,
    "title": "From Student to Freelancer: My Journey Since 2021",
    "excerpt": "Reflecting on my coding journey from learning HTML and CSS in school to becoming a freelance developer. The challenges, learnings, and growth over the past few years.",
    "content": "Looking back at my coding journey since 2021, I'm amazed at how much I've learned and grown. From writing my first HTML page to building full-stack applications for clients, it's been an incredible journey.\n\nI. The Beginning (2021)\n\nI started learning programming in school with basic HTML, CSS, and JavaScript. My first project was a simple calculator that could perform basic arithmetic operations. It wasn't much, but it sparked my interest in web development.\n\nII. Early Projects (2022)\n\nIn 2022, I built my first real project - the Event Countdown Timer. This vanilla JavaScript application taught me about DOM manipulation, local storage, and user interface design. It was also my first experience with responsive design.\n\nIII. Framework Exploration (2023)\n\n2023 was a year of exploration. I built projects with React, Vue, and Angular:\n• Travelogue with React and Leaflet.js\n• Habit Tracker PWA with React\n• Personal Finance Tracker with Vue 3\n• Fitness Class Scheduler with Angular\n\nEach framework taught me different approaches to building web applications.\n\nIV. Going Freelance (March 2024)\n\nIn March 2024, I took the leap into freelancing. My first client project was a school website for Rasoha Academy. This project taught me about client communication, project management, and delivering production-ready applications.\n\nV. Full-Stack Growth (2024)\n\nLater in 2024, I built my first full-stack applications:\n• Attendance System with React, Node.js, and MongoDB\n• E-Learning Platform with React and Django\n\nThese projects taught me about backend development, database design, and API development.\n\nVI. Advanced Projects (2025)\n\nMy latest project, TaskForge, represents the culmination of everything I've learned. It's a real-time collaborative platform built with Next.js, Socket.io, and MongoDB.\n\nVII. Key Learnings\n\n1. **Consistency is Key**: Regular practice and building projects is more important than perfect tutorials\n2. **Real Projects Teach More**: Building real applications teaches you things that tutorials can't\n3. **Client Communication**: Learning to communicate with clients is as important as technical skills\n4. **Continuous Learning**: The tech industry moves fast, and staying updated is crucial\n\nVIII. Looking Forward\n\nI'm excited to continue growing as a developer and taking on more challenging projects. The journey from student to freelancer has been incredible, and I can't wait to see what the future holds.",
    "tags": ["Journey", "Learning", "Freelancing", "Growth", "Reflection"],
    "date": "2024-09-15",
    "readTime": "12 min read",
    "image": "/assets/projects/attendance.jpg",
    "author": {
      "name": "Ancel Ajanga",
      "avatar": "/assets/profile-photo.jpg",
      "bio": "Full-stack developer passionate about building scalable web applications"
    }
  },
  {
    "id": 6,
    "title": "How Travelogue Taught Me the Power of Maps in Web Apps",
    "excerpt": "Building an interactive travel website with Leaflet.js and OpenStreetMap. Exploring the potential of maps in web applications and the technical challenges of map integration.",
    "content": "Maps have the power to transform web applications from static pages into interactive experiences. Building Travelogue taught me how to harness this power effectively.\n\nI. Why Maps Matter\n\nMaps provide context, location awareness, and interactive exploration that static content cannot match. For a travel website, maps are essential for helping users discover destinations and plan their journeys.\n\nII. Technical Implementation\n\n1. Leaflet.js Integration\n   • Open source and free to use\n   • Lightweight and fast\n   • Excellent plugin ecosystem\n   • No API key requirements\n\n2. OpenStreetMap Data\n   OpenStreetMap provides comprehensive, community-driven map data that's perfect for travel applications. The data is detailed and constantly updated by contributors worldwide.\n\nIII. Key Features\n\n1. Interactive Map\n   • Clickable destination markers\n   • Popup windows with travel information\n   • Custom map styling\n   • Responsive design for all devices\n\n2. Travel Stories\n   • Blog-style layout for travel experiences\n   • Photo galleries with lightbox functionality\n   • Search and filter capabilities\n   • Social sharing features\n\n3. User Experience\n   • Smooth map interactions\n   • Fast loading times\n   • Offline map caching\n   • Mobile-optimized interface\n\nIV. Technical Challenges\n\n1. Performance Optimization\n   • Lazy loading of map tiles\n   • Efficient marker clustering\n   • Optimized image loading\n   • Minimal bundle size\n\n2. Responsive Design\n   • Map resizing on device rotation\n   • Touch-friendly interactions\n   • Adaptive layouts for different screen sizes\n\n3. Data Management\n   • Efficient handling of large datasets\n   • Caching strategies for map data\n   • Real-time updates for new destinations\n\nV. Results\n\nTravelogue demonstrates how maps can enhance user engagement and provide valuable functionality. The interactive map makes it easy for users to explore destinations and discover new places to visit.\n\nVI. Lessons Learned\n\n1. Maps are Powerful: When used correctly, maps can significantly enhance user experience\n2. Performance Matters: Map applications need careful optimization to maintain smooth performance\n3. User Experience: Map interactions should be intuitive and responsive\n4. Data Quality: Good map data is essential for a successful map application\n\nVII. Future Enhancements\n\nI'm planning to add:\n• Route planning between destinations\n• User-generated content and reviews\n• Integration with travel APIs\n• Offline map downloads\n\nTravelogue taught me that maps are not just a feature - they're a powerful tool for creating engaging, interactive web experiences.",
    "tags": ["Maps", "Leaflet.js", "Travel", "Interactive", "OpenStreetMap"],
    "date": "2024-08-20",
    "readTime": "9 min read",
    "image": "/assets/projects/travel.jpg",
    "author": {
      "name": "Ancel Ajanga",
      "avatar": "/assets/profile-photo.jpg",
      "bio": "Full-stack developer passionate about building scalable web applications"
    }
  }
  ,
  {
    "id": 7,
    "title": "Designing a Console Banking System to Showcase OOP (Java)",
    "excerpt": "A deep dive into a pure Java console application that demonstrates encapsulation, inheritance, abstraction, and polymorphism through realistic banking operations.",
    "content": "This project intentionally avoids frameworks and databases to focus on the fundamentals of object‑oriented design.\n\nI. Goals\n• Demonstrate core OOP principles clearly\n• Keep the runtime environment simple (pure Java)\n• Model realistic banking flows (accounts, customers, transactions)\n\nII. Domain Model\n• Abstract `Account` defines shared state/behavior; `SavingsAccount` and `CheckingAccount` implement specifics (e.g., interest or overdraft rules)\n• `Bank` aggregates customers and accounts; coordinates transfers\n• `Transaction` logs operations with type (deposit, withdrawal, transfer) and timestamps\n\nIII. OOP Principles in Practice\n1. Encapsulation: Private fields, validation inside methods like `deposit`/`withdraw`\n2. Inheritance: Specialized accounts extend `Account`\n3. Abstraction: Abstract base class for common behavior\n4. Polymorphism: Methods operate on `Account` references regardless of concrete type\n\nIV. Running It\n```\njavac src/com/bankingsystem/*.java\njava -cp src com.bankingsystem.Main\n```\n\nV. Why This Matters\nThis kind of focused project is great for interviews and code reviews—it shows clarity of thought, clean APIs, and attention to correctness.\n\nSource: https://github.com/Ancel-duke/banking",
    "tags": ["Java", "OOP", "Design", "Console"],
    "date": "2025-09-22",
    "readTime": "5 min read",
    "image": "/assets/projects/bank.jpg",
    "author": {
      "name": "Ancel Ajanga",
      "avatar": "/assets/profile-photo.jpg",
      "bio": "Fullstack Software Engineer/Developer & App Developer"
    }
  },
  {
    "id": 8,
    "title": "Building EduChain: A Web3 Journey into Blockchain Certificate Management",
    "excerpt": "Exploring the challenges and solutions in building a full-stack Web3 application that issues verifiable academic certificates as ERC721 NFTs on the Ethereum blockchain.",
    "content": "EduChain represents my first deep dive into Web3 development, combining traditional full-stack skills with blockchain technology to solve a real-world problem in education.\n\nI. The Problem\n\nTraditional paper certificates and digital PDFs are easily forged, difficult to verify, and can be lost or damaged. Educational institutions need a secure, decentralized solution to issue and verify academic credentials that cannot be tampered with and remain permanently accessible.\n\nII. The Solution\n\nI built EduChain as a blockchain-based certificate management system leveraging ERC721 NFT standards. Each certificate is permanently stored on the Ethereum blockchain with metadata on IPFS, ensuring tamper-proof verification and permanent accessibility.\n\nIII. Technical Architecture\n\n1. Frontend (React 19)\n   • RainbowKit for seamless wallet connection\n   • Wagmi hooks for Ethereum interactions\n   • ethers.js v6 for smart contract communication\n   • Clean grayscale UI design\n   • Real-time blockchain state updates\n\n2. Backend (Node.js + Express)\n   • RESTful API for certificate management\n   • MongoDB for efficient querying\n   • IPFS integration via Pinata API\n   • Automatic metadata upload and retrieval\n   • Comprehensive error handling\n\n3. Smart Contracts (Solidity)\n   • ERC721 standard for NFT functionality\n   • OpenZeppelin v5 for security\n   • Owner-only minting for access control\n   • ReentrancyGuard protection\n   • Non-transferable NFTs to prevent trading\n\nIV. Key Challenges Solved\n\n1. Web3 Integration Complexity\n   Successfully integrated multiple Web3 libraries (RainbowKit, Wagmi, ethers.js) with proper async handling and provider management. The challenge was coordinating frontend, backend, and blockchain interactions seamlessly.\n\n2. IPFS Metadata Management\n   Implemented automatic metadata upload and retrieval from IPFS via Pinata. This required careful handling of async operations and error cases.\n\n3. Production Deployment\n   Resolved Node.js version conflicts, peer dependency issues, and environment variable synchronization across Netlify (frontend), Render (backend), and Sepolia testnet (smart contracts).\n\n4. Contract Interaction\n   Fixed ethers.js v6 async signer issues and implemented proper read-only contract calls. Configured multi-network support with proper chain switching.\n\nV. Security Features\n\n• Owner-only minting prevents unauthorized certificate issuance\n• ReentrancyGuard protection against smart contract attacks\n• Input validation on all contract functions\n• Non-transferable NFTs prevent certificate trading\n• Cryptographic verification ensures certificate authenticity\n\nVI. Results\n\nEduChain is now a fully functional Web3 application with:\n• Production deployment on Netlify, Render, and Sepolia testnet\n• Secure smart contract with OpenZeppelin audited patterns\n• Dual storage system (MongoDB for queries, IPFS for metadata, Blockchain for verification)\n• Comprehensive error handling and loading states\n• Clean, professional UI with excellent user experience\n\nVII. Lessons Learned\n\n1. Web3 Development: Building on blockchain requires understanding of gas fees, network configurations, and wallet interactions\n2. Decentralized Storage: IPFS provides permanent, decentralized storage but requires careful integration\n3. Smart Contract Security: Using audited libraries like OpenZeppelin is crucial for security\n4. Production Deployment: Web3 applications require coordination across multiple platforms\n5. User Experience: Wallet connections and blockchain interactions need clear feedback and error handling\n\nVIII. Future Enhancements\n\nI'm planning to add:\n• Multi-chain support (Polygon, Arbitrum)\n• Batch certificate minting\n• Certificate revocation mechanism\n• Enhanced verification features\n• Mobile wallet support\n\nEduChain taught me that Web3 development combines traditional full-stack skills with blockchain expertise, creating new possibilities for secure, decentralized applications.\n\nSource: https://github.com/Ancel-duke/EduChain",
    "tags": ["Web3", "Blockchain", "Solidity", "NFT", "IPFS", "Ethereum"],
    "date": "2026-01-20",
    "readTime": "12 min read",
    "image": "/assets/projects/EduChain.jpg",
    "author": {
      "name": "Ancel Ajanga",
      "avatar": "/assets/profile-photo.jpg",
      "bio": "Fullstack Software Engineer/Developer & App Developer"
    }
  }
]

