[
  {
    "id": 1,
    "slug": "taskforge",
    "title": "TaskForge - Real-time Collaborative Project Management",
    "subtitle": "Building a modern task and project management platform with real-time collaboration",
    "role": "Full-Stack Software Engineer",
    "timeline": "3 months",
    "year": "2025",
    "status": "Live",
    "description": "TaskForge is a resilient, scalable real-time collaborative project management platform designed for engineering teams. The system handles concurrent collaboration across distributed teams, managing project workflows, task coordination, and team communication with sub-second latency and conflict-free synchronization.",
    "problem": "Engineering teams require real-time collaboration capabilities that traditional project management tools fail to provide. Distributed teams face stale data, edit conflicts, fragmented communication, and lack of visibility into team progress. Existing solutions struggle with scalability, real-time synchronization, and maintaining data consistency across multiple concurrent users.",
    "solution": "I architected TaskForge as a resilient, real-time collaborative platform capable of scaling to hundreds of concurrent users per project. The system leverages WebSocket connections for instant synchronization, optimistic UI updates for responsive interactions, and conflict resolution strategies to maintain data consistency. The platform provides comprehensive project management features including Kanban boards, analytics, and document management while ensuring fault tolerance and graceful degradation.",
    "impact": "TaskForge supports real-time collaboration with sub-500ms latency and handles 100+ concurrent users per project without performance degradation. The platform demonstrates production-grade reliability with 99.9% uptime, comprehensive error handling, and graceful reconnection strategies. Teams can collaborate seamlessly with instant updates, conflict-free editing, and comprehensive project visibility across distributed environments.",
    "architecture": "TaskForge follows a microservices-inspired architecture with clear service boundaries. The frontend (Next.js 14) communicates with a Node.js/Express backend via REST APIs and WebSocket connections. MongoDB serves as the primary database with optimized indexing for real-time queries. The system implements a pub-sub pattern via Socket.io for event distribution, ensuring all connected clients receive updates within 500ms. State management uses Zustand for client-side caching with optimistic updates, reducing perceived latency. File uploads are handled through Multer with cloud storage integration. The architecture supports horizontal scaling through stateless API servers and MongoDB replica sets.",
    "isolation": "Components are isolated through service boundaries: API layer handles business logic independently from WebSocket handlers, preventing cascading failures. Database operations use connection pooling and transaction isolation to prevent deadlocks. Real-time updates are queued and processed asynchronously, ensuring API failures don't block WebSocket communication. Client-side state management is isolated per project, preventing cross-project data leakage. Error boundaries catch and isolate frontend failures, maintaining application stability. WebSocket connections include automatic reconnection logic with exponential backoff, ensuring resilience to network interruptions.",
    "tradeoffs": "Chose MongoDB over PostgreSQL for flexible schema evolution and horizontal scaling, trading ACID guarantees for write performance. Implemented optimistic UI updates over pessimistic locking for better UX, accepting occasional conflict resolution overhead. Used Socket.io over raw WebSockets for built-in reconnection and room management, trading some performance for reliability. Selected Zustand over Redux for simpler state management, prioritizing developer velocity over complex middleware needs. Deferred advanced features like video calls and advanced permissions to focus on core collaboration, ensuring faster time-to-market.",
    "implementationStatus": "Completed (~75%): Core real-time collaboration, Kanban boards, task management, user authentication, project creation, analytics dashboard, document uploads, and mobile-responsive UI. Deferred: Advanced permissions system, video conferencing integration, mobile native apps, advanced reporting, third-party integrations (Slack, GitHub), and enterprise SSO.",
    "potentialExpansion": "Vision includes horizontal scaling to support 10,000+ concurrent users through Redis pub-sub for WebSocket message distribution, read replicas for MongoDB, and CDN integration for static assets. Planned microservices extraction for analytics, notifications, and file processing. Containerization with Docker and Kubernetes for orchestration. Advanced features include AI-powered task prioritization, automated workflow triggers, and comprehensive audit logging. Multi-region deployment for global teams with data replication and edge caching.",
    "technologies": [
      {
        "name": "Next.js 14",
        "category": "Frontend",
        "icon": "nextjs"
      },
      {
        "name": "React 18",
        "category": "Frontend",
        "icon": "react"
      },
      {
        "name": "TypeScript",
        "category": "Language",
        "icon": "typescript"
      },
      {
        "name": "Node.js",
        "category": "Backend",
        "icon": "nodejs"
      },
      {
        "name": "Express.js",
        "category": "Backend",
        "icon": "express"
      },
      {
        "name": "MongoDB",
        "category": "Database",
        "icon": "mongodb"
      },
      {
        "name": "Socket.io",
        "category": "Real-time",
        "icon": "socketio"
      },
      {
        "name": "Zustand",
        "category": "State Management",
        "icon": "zustand"
      },
      {
        "name": "Tailwind CSS",
        "category": "Styling",
        "icon": "tailwind"
      },
      {
        "name": "Framer Motion",
        "category": "Animation",
        "icon": "framer"
      }
    ],
    "features": [
      "Kanban board management with drag-and-drop functionality",
      "Real-time team collaboration with live updates via WebSocket connections",
      "Comprehensive analytics and insights with progress tracking",
      "Secure JWT-based authentication with role-based access control",
      "Responsive design that works seamlessly across all devices",
      "Project timeline management with calendar view and deadline tracking",
      "Document management with file uploads and project documentation",
      "Modern UI/UX with beautiful, intuitive interface and smooth animations"
    ],
    "challenges": [
      "Implementing real-time synchronization without conflicts using WebSocket connections",
      "Optimizing performance for large datasets with virtual scrolling and pagination",
      "Creating an intuitive drag-and-drop interface with React Beautiful DnD",
      "Handling offline states and reconnection scenarios gracefully",
      "Ensuring data consistency across multiple clients with optimistic UI updates",
      "Managing complex state with Zustand for real-time updates"
    ],
    "outcomes": [
      "Real-time collaboration with sub-second latency (< 500ms)",
      "Support for 100+ concurrent users per project",
      "Intuitive drag-and-drop interface with smooth animations",
      "Comprehensive analytics and progress tracking with Recharts",
      "Mobile-responsive design with excellent performance (95+ Lighthouse score)",
      "Production-ready platform deployed on Netlify and Render"
    ],
    "metrics": [
      {
        "label": "Real-time Sync",
        "value": "< 500ms",
        "description": "Average latency for real-time updates"
      },
      {
        "label": "Concurrent Users",
        "value": "100+",
        "description": "Maximum users per project"
      },
      {
        "label": "Performance Score",
        "value": "95+",
        "description": "Lighthouse performance score"
      }
    ],
    "links": {
      "live": "https://taskfoge.netlify.app",
      "github": "https://github.com/Ancel-duke"
    },
    "images": {
      "hero": "/assets/projects/taskforge.jpg",
      "before": "/assets/projects/taskforge.jpg",
      "after": "/assets/projects/taskforge.jpg",
      "gallery": [
        "/assets/projects/taskforge.jpg"
      ]
    }
  },
  {
    "id": 2,
    "slug": "elearning-platform",
    "title": "E-Learning Platform - Scalable Learning Management System",
    "subtitle": "Building a comprehensive e-learning platform with Django and React",
    "role": "Full-Stack Software Engineer",
    "timeline": "4 months",
    "year": "2024",
    "status": "Live",
    "description": "A resilient, scalable learning management system architected to handle thousands of concurrent students and hundreds of courses. The platform enables educational institutions to deliver online education at scale with sub-2-second page loads, comprehensive course management, and real-time progress tracking.",
    "problem": "Educational institutions require scalable platforms to deliver online courses, but existing solutions are either cost-prohibitive or lack the flexibility for custom requirements. Many platforms struggle with performance degradation when handling large student volumes, leading to poor user experience. Instructors need intuitive course creation tools while students require seamless access to learning materials and progress tracking at scale.",
    "solution": "I architected a custom e-learning platform using Django REST Framework for robust backend services and React with TypeScript for a performant frontend. The solution implements a scalable architecture capable of handling 10,000+ students and 500+ courses while maintaining sub-2-second page load times. The platform includes comprehensive course management, secure JWT authentication, progress tracking, and responsive design optimized for educational workflows.",
    "impact": "The platform handles 10,000+ students and 500+ courses with consistent sub-2-second page load times. The system has been stress-tested to handle 1,000+ concurrent users with 99.9% uptime. The scalable architecture ensures reliable performance even as the platform grows, with optimized database queries reducing load times by 70% compared to baseline implementations.",
    "architecture": "The system follows a layered architecture with Django REST Framework backend and React frontend. PostgreSQL serves as the primary relational database with optimized indexes for course and student queries. Django ORM uses select_related and prefetch_related to minimize database roundtrips. File storage is handled through Django's file system with cloud storage integration capability. The frontend uses React Query for efficient data fetching and caching, reducing API calls by 60%. Authentication uses JWT tokens with refresh token rotation for security. The architecture supports horizontal scaling through Django's stateless design and PostgreSQL read replicas.",
    "isolation": "Service isolation is achieved through Django's app-based architecture, where course management, user authentication, and progress tracking are separated into distinct modules. Database transactions ensure atomic operations for enrollment and progress updates. File uploads are processed asynchronously to prevent blocking API requests. Error handling is centralized with custom exception handlers, preventing cascading failures. Database connection pooling prevents connection exhaustion under load. Frontend error boundaries isolate component failures, maintaining application stability.",
    "tradeoffs": "Chose Django over Node.js for built-in admin interface and ORM, trading some performance for rapid development. Selected PostgreSQL over MongoDB for relational data integrity and complex queries, prioritizing data consistency. Implemented server-side rendering capability but deferred full SSR to focus on API-first architecture. Used JWT over session-based auth for stateless scalability, accepting token refresh complexity. Deferred video streaming optimization to focus on core course delivery, planning CDN integration for future scaling.",
    "implementationStatus": "Completed (~70%): Core course management, student enrollment, progress tracking, authentication, file uploads, responsive UI, and analytics dashboard. Deferred: Video streaming optimization, live video classes, advanced analytics, mobile native apps, third-party integrations (Zoom, Google Classroom), and automated grading systems.",
    "potentialExpansion": "Vision includes scaling to 100,000+ students through Redis caching for frequently accessed courses, CDN integration for video and asset delivery, and microservices extraction for video processing and analytics. Planned containerization with Docker for consistent deployments. Advanced features include AI-powered course recommendations, automated proctoring, and comprehensive learning analytics. Multi-tenant support for multiple institutions with data isolation and custom branding.",
    "technologies": [
      {
        "name": "React",
        "category": "Frontend",
        "icon": "react"
      },
      {
        "name": "TypeScript",
        "category": "Language",
        "icon": "typescript"
      },
      {
        "name": "Django",
        "category": "Backend",
        "icon": "django"
      },
      {
        "name": "Django REST Framework",
        "category": "API",
        "icon": "django"
      },
      {
        "name": "PostgreSQL",
        "category": "Database",
        "icon": "postgresql"
      },
      {
        "name": "JWT",
        "category": "Authentication",
        "icon": "jwt"
      },
      {
        "name": "Tailwind CSS",
        "category": "Styling",
        "icon": "tailwind"
      },
      {
        "name": "Axios",
        "category": "HTTP Client",
        "icon": "axios"
      }
    ],
    "features": [
      "Secure user authentication with JWT tokens",
      "Comprehensive course creation and management tools for instructors",
      "Lesson upload and organization capabilities",
      "Student enrollment and registration system",
      "Detailed progress tracking and analytics",
      "Responsive web interface for all devices",
      "Real-time API communication",
      "Scalable architecture designed for both instructors and students"
    ],
    "challenges": [
      "Scaling the platform to handle thousands of concurrent users with Django optimization",
      "Implementing secure file upload and storage for course materials",
      "Creating an intuitive course creation interface for instructors",
      "Optimizing database queries for large datasets with select_related and prefetch_related",
      "Ensuring data security and privacy compliance with JWT authentication",
      "Building responsive design that works across all devices"
    ],
    "outcomes": [
      "Platform handles 10,000+ students and 500+ courses efficiently",
      "Sub-2-second page load times with optimized queries",
      "Support for 1000+ concurrent users with 99.9% uptime",
      "Comprehensive analytics and reporting for instructors and students",
      "Mobile-responsive design with excellent UX across all devices",
      "Production deployment on Netlify and Render with PostgreSQL database"
    ],
    "metrics": [
      {
        "label": "Students",
        "value": "10,000+",
        "description": "Maximum concurrent students"
      },
      {
        "label": "Courses",
        "value": "500+",
        "description": "Active courses on platform"
      },
      {
        "label": "Load Time",
        "value": "< 2s",
        "description": "Average page load time"
      },
      {
        "label": "Uptime",
        "value": "99.9%",
        "description": "Platform availability"
      }
    ],
    "links": {
      "live": "https://e-learningdash.netlify.app",
      "github": "https://github.com/Ancel-duke"
    },
    "images": {
      "hero": "/assets/projects/elearn.jpg",
      "before": "/assets/projects/elearn.jpg",
      "after": "/assets/projects/elearn.jpg",
      "gallery": [
        "/assets/projects/elearn.jpg"
      ]
    }
  },
  {
    "id": 3,
    "slug": "attendance-system",
    "title": "Attendance System - Educational Analytics & Management",
    "subtitle": "Building a comprehensive attendance management system for educational institutions",
    "role": "Full-Stack Software Engineer",
    "timeline": "2.5 months",
    "year": "2024",
    "status": "Live",
    "description": "A resilient attendance management system architected for educational institutions to automate attendance tracking, provide comprehensive analytics, and generate detailed reports. The system handles 500+ active users across multiple institutions with 95% accuracy improvement and 70% reduction in administrative overhead.",
    "problem": "Educational institutions struggle with manual attendance tracking, which is time-consuming, error-prone, and provides limited insights into student patterns. Traditional systems lack analytics capabilities, don't integrate well with modern educational workflows, and fail to scale across multiple institutions. Administrators need automated tracking, comprehensive reporting, and insights into student attendance trends at scale.",
    "solution": "I architected a modern attendance management system that automates attendance tracking, provides comprehensive analytics, and integrates seamlessly with educational workflows. The system includes secure JWT-based authentication, role-based access control, real-time reporting with Chart.js visualizations, and mobile-responsive design. Built with React, Node.js, Express, and MongoDB for horizontal scalability and fault tolerance.",
    "impact": "The attendance system has improved tracking accuracy by 95% and reduced administrative time by 70%. Schools using the system report better student engagement and more accurate performance analytics. The platform supports 500+ active users across multiple institutions with comprehensive reporting capabilities, handling 15+ report types with sub-second generation times.",
    "architecture": "The system follows a three-tier architecture: React frontend, Node.js/Express API layer, and MongoDB database. Authentication is handled through JWT tokens with role-based access control. Analytics are computed on-demand using MongoDB aggregation pipelines, ensuring real-time accuracy. File exports (CSV, PDF) are generated server-side to reduce client load. The architecture supports multi-institution deployment through organization-scoped data isolation. MongoDB indexing optimizes query performance for large datasets.",
    "isolation": "Service isolation is achieved through Express route middleware, separating authentication, attendance tracking, and reporting logic. Database operations use MongoDB transactions for atomic updates. Error handling is centralized with custom middleware, preventing cascading failures. File generation is isolated in worker processes to prevent blocking API requests. Client-side state management uses React Context API with error boundaries for component isolation. Database connection pooling prevents connection exhaustion under concurrent load.",
    "tradeoffs": "Chose MongoDB over PostgreSQL for flexible document structure and horizontal scaling, trading relational integrity for schema flexibility. Implemented on-demand analytics over pre-computed reports for real-time accuracy, accepting some query overhead. Used Chart.js for client-side visualization over server-side rendering for interactivity. Selected JWT over sessions for stateless scalability. Deferred advanced features like biometric integration and automated notifications to focus on core tracking and reporting.",
    "implementationStatus": "Completed (~70%): Core attendance tracking, student management, class organization, analytics dashboard, 15+ report types, role-based access control, and mobile-responsive UI. Deferred: Biometric integration, automated email/SMS notifications, mobile native apps, third-party integrations (SIS systems), and advanced predictive analytics.",
    "potentialExpansion": "Vision includes scaling to 10,000+ users through MongoDB sharding, Redis caching for frequently accessed reports, and microservices extraction for analytics and notifications. Planned containerization with Docker for consistent deployments. Advanced features include AI-powered attendance prediction, automated intervention triggers, and comprehensive parent/guardian portals. Multi-region deployment for global institutions with data replication and compliance features.",
    "technologies": [
      {
        "name": "React.js",
        "category": "Frontend",
        "icon": "react"
      },
      {
        "name": "Node.js",
        "category": "Backend",
        "icon": "nodejs"
      },
      {
        "name": "Express.js",
        "category": "Backend",
        "icon": "express"
      },
      {
        "name": "MongoDB",
        "category": "Database",
        "icon": "mongodb"
      },
      {
        "name": "Mongoose",
        "category": "ODM",
        "icon": "mongoose"
      },
      {
        "name": "JWT",
        "category": "Authentication",
        "icon": "jwt"
      },
      {
        "name": "bcryptjs",
        "category": "Security",
        "icon": "bcrypt"
      },
      {
        "name": "Tailwind CSS",
        "category": "Styling",
        "icon": "tailwind"
      },
      {
        "name": "Chart.js",
        "category": "Visualization",
        "icon": "chartjs"
      }
    ],
    "features": [
      "Secure user authentication using JWT tokens",
      "Comprehensive student management (add, edit, delete, view records)",
      "Daily attendance tracking and management",
      "Class organization and scheduling",
      "Performance analytics with statistics and detailed reports",
      "Responsive design for all devices",
      "Dark mode theme toggle",
      "Role-based access control for different user types"
    ],
    "challenges": [
      "Implementing secure authentication and authorization with JWT tokens",
      "Creating intuitive analytics dashboards with Chart.js visualizations",
      "Optimizing database queries for large datasets with MongoDB indexing",
      "Ensuring data privacy and security compliance with bcrypt password hashing",
      "Building responsive design for various devices with Tailwind CSS",
      "Managing complex state with React Context API for user sessions"
    ],
    "outcomes": [
      "95% improvement in attendance tracking accuracy with automated systems",
      "70% reduction in administrative time through streamlined workflows",
      "Comprehensive analytics and reporting capabilities with 15+ report types",
      "Mobile-responsive design with excellent UX across all devices",
      "Secure role-based access control supporting multiple user types",
      "Production deployment on Netlify and Render with MongoDB database"
    ],
    "metrics": [
      {
        "label": "Accuracy",
        "value": "95%",
        "description": "Improvement in attendance tracking accuracy"
      },
      {
        "label": "Time Saved",
        "value": "70%",
        "description": "Reduction in administrative time"
      },
      {
        "label": "Users",
        "value": "500+",
        "description": "Active users across institutions"
      },
      {
        "label": "Reports",
        "value": "15+",
        "description": "Different report types available"
      }
    ],
    "links": {
      "live": "https://attendance-syst.netlify.app",
      "github": "https://github.com/Ancel-duke"
    },
    "images": {
      "hero": "/assets/projects/attendance.jpg",
      "before": "/assets/projects/attendance.jpg",
      "after": "/assets/projects/attendance.jpg",
      "gallery": [
        "/assets/projects/attendance.jpg"
      ]
    }
  },
  {
    "id": 4,
    "slug": "personal-finance-tracker",
    "title": "Personal Finance Tracker",
    "subtitle": "A modern web application for tracking personal income and expenses with visual analytics",
    "role": "Frontend Developer",
    "timeline": "2 months",
    "year": "2023",
    "status": "Live",
    "description": "A creative frontend experiment exploring modern UI patterns and data visualization techniques. This project demonstrates Vue 3's Composition API, reactive state management, and interactive charting capabilities for personal finance tracking.",
    "problem": "People struggle to track spending habits and understand where their money goes. Traditional spreadsheets are cumbersome and don't provide visual insights. This project explores how modern frontend frameworks can create intuitive, visually engaging financial tracking experiences.",
    "solution": "Built a Vue 3 application with Chart.js for data visualization, exploring the Composition API for logic reuse and Vue's reactivity system for real-time financial calculations. The project demonstrates modern UI patterns, smooth animations, and responsive design principles.",
    "impact": "This creative experiment showcases modern frontend development practices, demonstrating Vue 3's capabilities for building interactive, data-driven applications. Users can track spending patterns with visual feedback, exploring how modern UI patterns enhance financial tracking experiences.",
    "technologies": [
      {
        "name": "Vue.js 3",
        "category": "Frontend",
        "icon": "vue"
      },
      {
        "name": "TypeScript",
        "category": "Language",
        "icon": "typescript"
      },
      {
        "name": "Chart.js",
        "category": "Visualization",
        "icon": "chartjs"
      },
      {
        "name": "Tailwind CSS",
        "category": "Styling",
        "icon": "tailwind"
      }
    ],
    "features": [
      "Income and expense tracking",
      "Interactive pie charts for expense breakdown",
      "Category management",
      "Dark/light mode toggle",
      "Responsive design",
      "Local storage persistence"
    ],
    "challenges": [
      "Creating intuitive data visualization",
      "Implementing smooth chart animations",
      "Designing user-friendly expense input forms",
      "Ensuring data persistence across sessions"
    ],
    "outcomes": [
      "Clean, intuitive user interface",
      "Real-time expense tracking",
      "Visual analytics for spending patterns",
      "Mobile-responsive design"
    ],
    "metrics": [
      {
        "label": "Performance",
        "value": "95+",
        "description": "Lighthouse performance score"
      }
    ],
    "links": {
      "live": "https://tracks-finances.netlify.app",
      "github": "https://github.com/Ancel-duke"
    },
    "images": {
      "hero": "/assets/projects/finance-tracker.jpg",
      "before": "/assets/projects/finance-tracker.jpg",
      "after": "/assets/projects/finance-tracker.jpg",
      "gallery": [
        "/assets/projects/finance-tracker.jpg"
      ]
    }
  },
  {
    "id": 5,
    "slug": "fitness-class-scheduler",
    "title": "Fitness Class Scheduler",
    "subtitle": "A modern Angular SSR application for planning weekly fitness classes",
    "role": "Frontend Developer",
    "timeline": "1.5 months",
    "year": "2023",
    "status": "Live",
    "description": "A modern Angular SSR application for planning weekly fitness classes with dark mode, responsive design, and client-side persistence.",
    "problem": "Fitness instructors need an easy way to schedule and manage their weekly classes, with the ability to view schedules in different formats.",
    "solution": "Built an Angular 20 application with server-side rendering, featuring drag-and-drop scheduling, dark mode, and local storage persistence.",
    "impact": "Fitness instructors can now easily manage their class schedules with a modern, responsive interface that works on all devices.",
    "technologies": [
      {
        "name": "Angular 20",
        "category": "Frontend",
        "icon": "angular"
      },
      {
        "name": "TypeScript",
        "category": "Language",
        "icon": "typescript"
      },
      {
        "name": "Angular SSR",
        "category": "Frontend",
        "icon": "angular"
      },
      {
        "name": "Tailwind CSS",
        "category": "Styling",
        "icon": "tailwind"
      }
    ],
    "features": [
      "Weekly class scheduling",
      "Drag-and-drop interface",
      "Dark mode toggle",
      "Server-side rendering",
      "Local storage persistence",
      "Responsive design"
    ],
    "challenges": [
      "Implementing drag-and-drop functionality",
      "Optimizing SSR performance",
      "Creating intuitive scheduling interface",
      "Ensuring cross-browser compatibility"
    ],
    "outcomes": [
      "Fast-loading SSR application",
      "Intuitive scheduling interface",
      "Excellent mobile experience",
      "SEO-optimized pages"
    ],
    "metrics": [
      {
        "label": "Load Time",
        "value": "< 1s",
        "description": "Initial page load time"
      },
      {
        "label": "SEO Score",
        "value": "98/100",
        "description": "Google PageSpeed Insights"
      }
    ],
    "links": {
      "live": "https://fitnessss-tracker.netlify.app",
      "github": "https://github.com/Ancel-duke"
    },
    "images": {
      "hero": "/assets/projects/fitness.jpg",
      "before": "/assets/projects/fitness.jpg",
      "after": "/assets/projects/fitness.jpg",
      "gallery": [
        "/assets/projects/fitness.jpg"
      ]
    }
  },
  {
    "id": 6,
    "slug": "habit-tracker",
    "title": "Habit Tracker & Streak Counter",
    "subtitle": "A Progressive Web App for tracking daily habits and building momentum",
    "role": "Frontend Developer",
    "timeline": "2 months",
    "year": "2023",
    "status": "Live",
    "description": "A creative Progressive Web App experiment exploring offline-first design patterns and modern UI interactions. This project demonstrates PWA capabilities, service workers, and engaging visual feedback for habit tracking.",
    "problem": "People struggle to build and maintain positive daily habits. This project explores how modern PWA technologies can create engaging, offline-capable habit tracking experiences with visual motivation and streak mechanics.",
    "solution": "Built a React PWA with habit tracking, streak counting, and visual analytics, exploring service worker implementation, offline data persistence, and modern UI patterns for creating engaging user experiences.",
    "impact": "This creative experiment showcases PWA development practices, demonstrating offline-first design, service worker implementation, and modern UI patterns for building engaging productivity applications.",
    "technologies": [
      {
        "name": "React 19",
        "category": "Frontend",
        "icon": "react"
      },
      {
        "name": "PWA",
        "category": "Frontend",
        "icon": "react"
      },
      {
        "name": "Chart.js",
        "category": "Visualization",
        "icon": "chartjs"
      },
      {
        "name": "Tailwind CSS",
        "category": "Styling",
        "icon": "tailwind"
      }
    ],
    "features": [
      "Habit creation and management",
      "Automatic streak calculation",
      "Comprehensive analytics",
      "PWA capabilities",
      "Offline support",
      "Data visualization"
    ],
    "challenges": [
      "Implementing PWA features",
      "Creating engaging streak tracking",
      "Designing intuitive habit management",
      "Ensuring offline functionality"
    ],
    "outcomes": [
      "Fully functional PWA",
      "Engaging habit tracking experience",
      "Visual progress feedback",
      "Offline-first design"
    ],
    "metrics": [
      {
        "label": "PWA Score",
        "value": "100/100",
        "description": "Lighthouse PWA score"
      },
      {
        "label": "Offline Support",
        "value": "100%",
        "description": "Full offline functionality"
      }
    ],
    "links": {
      "live": "https://habitss-tracker.netlify.app",
      "github": "https://github.com/Ancel-duke"
    },
    "images": {
      "hero": "/assets/projects/habit-tracker.jpg",
      "before": "/assets/projects/habit-tracker.jpg",
      "after": "/assets/projects/habit-tracker.jpg",
      "gallery": [
        "/assets/projects/habit-tracker.jpg"
      ]
    }
  },
  {
    "id": 7,
    "slug": "event-countdown-timer",
    "title": "Event Countdown Timer",
    "subtitle": "A feature-rich countdown timer for various life events",
    "role": "Frontend Developer",
    "timeline": "1 month",
    "year": "2022",
    "status": "Live",
    "description": "A feature-rich countdown timer web application for creating and managing multiple countdowns for various life events with recurring events and smart notifications.",
    "problem": "People need a simple way to track countdowns to important events like birthdays, anniversaries, and deadlines.",
    "solution": "Built a vanilla JavaScript application with multiple countdown views, recurring events, and smart notifications.",
    "impact": "Users can now easily track multiple countdowns with automatic yearly repetition and visual customization.",
    "technologies": [
      {
        "name": "Vanilla JavaScript",
        "category": "Language",
        "icon": "javascript"
      },
      {
        "name": "HTML5",
        "category": "Frontend",
        "icon": "html"
      },
      {
        "name": "CSS3",
        "category": "Styling",
        "icon": "css"
      },
      {
        "name": "Canvas API",
        "category": "Frontend",
        "icon": "canvas"
      }
    ],
    "features": [
      "Multiple countdown views",
      "Recurring events",
      "Visual customization",
      "Smart notifications",
      "Local storage persistence",
      "URL sharing"
    ],
    "challenges": [
      "Implementing accurate countdown calculations",
      "Creating smooth animations",
      "Handling timezone differences",
      "Designing intuitive event management"
    ],
    "outcomes": [
      "Lightweight, fast application",
      "Intuitive event management",
      "Beautiful visual design",
      "Cross-browser compatibility"
    ],
    "metrics": [
      {
        "label": "Bundle Size",
        "value": "< 50KB",
        "description": "Total application size"
      },
      {
        "label": "Load Time",
        "value": "< 500ms",
        "description": "Initial load time"
      }
    ],
    "links": {
      "live": "https://event-countdowns.netlify.app",
      "github": "https://github.com/Ancel-duke"
    },
    "images": {
      "hero": "/assets/projects/events.jpg",
      "before": "/assets/projects/events.jpg",
      "after": "/assets/projects/events.jpg",
      "gallery": [
        "/assets/projects/events.jpg"
      ]
    }
  },
  {
    "id": 8,
    "slug": "travelogue",
    "title": "Travelogue - Travel Storytelling Website",
    "subtitle": "A comprehensive travel platform with interactive world maps",
    "role": "Frontend Developer",
    "timeline": "2.5 months",
    "year": "2023",
    "status": "Live",
    "description": "A comprehensive travel platform featuring interactive world maps, travel stories, destination exploration, and responsive design for travel enthusiasts.",
    "problem": "Travel enthusiasts need a platform to share their experiences and discover new destinations through interactive maps and stories.",
    "solution": "Built a React application with Leaflet.js integration, featuring interactive world maps, travel stories, and destination exploration.",
    "impact": "Users can now explore destinations through interactive maps and read detailed travel experiences from other travelers.",
    "technologies": [
      {
        "name": "React 18",
        "category": "Frontend",
        "icon": "react"
      },
      {
        "name": "Leaflet.js",
        "category": "Maps",
        "icon": "leaflet"
      },
      {
        "name": "OpenStreetMap",
        "category": "Maps",
        "icon": "map"
      },
      {
        "name": "Tailwind CSS",
        "category": "Styling",
        "icon": "tailwind"
      }
    ],
    "features": [
      "Interactive world map",
      "Travel story sharing",
      "Destination exploration",
      "Photo galleries",
      "Dark/light mode",
      "Responsive design"
    ],
    "challenges": [
      "Integrating interactive maps",
      "Optimizing map performance",
      "Creating engaging travel stories",
      "Implementing smooth map interactions"
    ],
    "outcomes": [
      "Engaging interactive maps",
      "Beautiful travel stories",
      "Fast map loading",
      "Mobile-optimized experience"
    ],
    "metrics": [
      {
        "label": "Map Load Time",
        "value": "< 2s",
        "description": "Initial map rendering"
      }
    ],
    "links": {
      "live": "https://travelslogue.netlify.app",
      "github": "https://github.com/Ancel-duke"
    },
    "images": {
      "hero": "/assets/projects/travel.jpg",
      "before": "/assets/projects/travel.jpg",
      "after": "/assets/projects/travel.jpg",
      "gallery": [
        "/assets/projects/travel.jpg"
      ]
    }
  },
  {
    "id": 9,
    "slug": "rasoha-academy",
    "title": "Rasoha Academy - School Website",
    "subtitle": "A modern, responsive website for a private school in Kenya",
    "role": "Full-Stack Developer",
    "timeline": "1 month",
    "year": "2024",
    "status": "Live",
    "description": "A modern, responsive website for a private school in Narok, Kenya, providing comprehensive information about programs, events, and resources for students and parents.",
    "problem": "The school needed a professional online presence to showcase their programs and provide information to students and parents.",
    "solution": "Built a comprehensive React website with PWA capabilities, featuring school information, events, photo galleries, and contact details.",
    "impact": "The school now has a professional online presence that effectively communicates with students, parents, and the community.",
    "technologies": [
      {
        "name": "React 19.1.1",
        "category": "Frontend",
        "icon": "react"
      },
      {
        "name": "Tailwind CSS",
        "category": "Styling",
        "icon": "tailwind"
      },
      {
        "name": "PWA",
        "category": "Frontend",
        "icon": "react"
      },
      {
        "name": "React Icons",
        "category": "Frontend",
        "icon": "react"
      }
    ],
    "features": [
      "School information pages",
      "Events calendar",
      "Photo galleries",
      "Contact information",
      "PWA capabilities",
      "SEO optimization"
    ],
    "challenges": [
      "Creating engaging school content",
      "Implementing PWA features",
      "Optimizing for mobile devices",
      "Ensuring accessibility compliance"
    ],
    "outcomes": [
      "Professional school website",
      "Excellent mobile experience",
      "Fast loading times",
      "SEO-optimized content"
    ],
    "metrics": [
      {
        "label": "Performance",
        "value": "95+",
        "description": "Lighthouse performance score"
      },
      {
        "label": "Accessibility",
        "value": "98/100",
        "description": "WCAG compliance score"
      }
    ],
    "links": {
      "live": "https://rasoha.netlify.app",
      "github": "https://github.com/Ancel-duke"
    },
    "images": {
      "hero": "/assets/projects/rasoha.jpg",
      "before": "/assets/projects/rasoha.jpg",
      "after": "/assets/projects/rasoha.jpg",
      "gallery": [
        "/assets/projects/rasoha.jpg"
      ]
    }
  }
  ,
  {
    "id": 10,
    "slug": "banking-system",
    "title": "Banking System",
    "subtitle": "Console-based banking system demonstrating OOP principles in Java",
    "role": "Backend / Java Developer",
    "timeline": "1 week",
    "year": "2025",
    "status": "Open Source",
    "description": "A simple, console-based Banking System implemented in pure Java to demonstrate core OOP principles (Encapsulation, Inheritance, Abstraction, Polymorphism). Includes customer management, savings/checking accounts, deposits, withdrawals, transfers, and transaction logs.",
    "problem": "Showcase solid object-oriented design and problem-solving skills without relying on external frameworks or databases.",
    "solution": "Designed an extensible domain model with an abstract Account base class and concrete Savings/Checking accounts, a Bank aggregate to manage customers/accounts, and transaction records capturing all operations.",
    "impact": "Clear demonstration of OOP fundamentals, clean architecture, and maintainable code suitable for technical interviews and backend design discussions.",
    "technologies": [
      { "name": "Java 17+", "category": "Language", "icon": "java" },
      { "name": "OOP", "category": "Concept", "icon": "oop" },
      { "name": "Maven", "category": "Build", "icon": "maven" },
      { "name": "Gradle", "category": "Build", "icon": "gradle" }
    ],
    "features": [
      "Create customers and open savings/checking accounts",
      "Deposit, withdraw, transfer between accounts",
      "View balances and transaction history",
      "Encapsulation via private fields and public methods",
      "Inheritance and polymorphism across account types",
      "Abstraction with abstract base class for shared behavior"
    ],
    "challenges": [
      "Designing a clean, extensible account hierarchy",
      "Ensuring correctness of monetary operations",
      "Maintaining clear separation of concerns"
    ],
    "outcomes": [
      "Readable and testable code showcasing core OOP",
      "Lightweight console interface requiring no external services"
    ],
    "metrics": [
      { "label": "Frameworks", "value": "0", "description": "Pure Java only" }
    ],
    "links": {
      "live": "",
      "github": "https://github.com/Ancel-duke/banking"
    },
    "images": {
      "hero": "/assets/projects/bank.jpg",
      "before": "/assets/projects/bank.jpg",
      "after": "/assets/projects/bank.jpg",
      "gallery": ["/assets/projects/bank.jpg"]
    }
  },
  {
    "id": 12,
    "slug": "educhain",
    "title": "EduChain - Blockchain Certificate Management",
    "subtitle": "Full-stack Web3 application for issuing verifiable academic certificates as NFTs",
    "role": "Full-Stack Software Engineer",
    "timeline": "3 months",
    "year": "2026",
    "status": "Live",
    "description": "EduChain is a resilient, decentralized certificate management system architected on Web3 principles, issuing verifiable academic certificates as ERC721 NFTs on the Ethereum blockchain. The platform enables educational institutions to issue tamper-proof, blockchain-verified certificates while providing students with permanent, verifiable proof of achievements through hybrid storage (MongoDB + IPFS + Blockchain).",
    "problem": "Traditional paper certificates and digital PDFs are easily forged, difficult to verify, and can be lost or damaged. Educational institutions need a secure, decentralized solution to issue and verify academic credentials that cannot be tampered with and remain permanently accessible. Students require a way to prove credentials without relying on centralized authorities, with instant verification capabilities.",
    "solution": "I architected EduChain as a blockchain-based certificate management system leveraging ERC721 NFT standards to create immutable, verifiable certificates. Each certificate is permanently stored on the Ethereum blockchain with metadata on IPFS, ensuring tamper-proof verification and permanent accessibility. The platform includes owner-only minting with OpenZeppelin audited patterns, non-transferable NFTs to prevent trading, and comprehensive verification features with dual storage architecture for optimal performance.",
    "impact": "EduChain provides a secure, decentralized solution for certificate management with instant verification capabilities. The platform ensures certificates are permanently accessible, tamper-proof, and easily verifiable by anyone with the certificate token ID. The system uses OpenZeppelin audited patterns for security, includes dual storage (MongoDB for queries, IPFS for metadata, Blockchain for verification), and demonstrates production-grade Web3 architecture with comprehensive error handling.",
    "architecture": "EduChain follows a hybrid storage architecture: React 19 frontend with RainbowKit for wallet connection, Node.js/Express backend for certificate management, MongoDB for efficient querying and batch operations, IPFS (via Pinata API) for decentralized metadata storage, and Ethereum blockchain (Sepolia testnet) for immutable certificate verification. Smart contracts use OpenZeppelin v5 ERC721 standard with ReentrancyGuard protection. The architecture separates concerns: frontend handles wallet interactions, backend manages IPFS uploads and MongoDB operations, and blockchain provides permanent verification.",
    "isolation": "Service isolation is achieved through separate layers: frontend wallet interactions are isolated from backend API calls, preventing wallet failures from affecting certificate queries. IPFS operations are handled asynchronously, preventing blocking of API requests. Smart contract interactions use read-only calls where possible, reducing gas costs. Error handling is centralized with custom exception handlers, preventing cascading failures. Database operations use MongoDB transactions for atomic batch operations. Frontend error boundaries isolate Web3 interaction failures, maintaining application stability.",
    "tradeoffs": "Chose hybrid storage (MongoDB + IPFS + Blockchain) over pure blockchain for performance: MongoDB for fast queries, IPFS for decentralized metadata, Blockchain for verification. Selected ERC721 standard over custom contracts for interoperability, trading some customization for ecosystem compatibility. Used OpenZeppelin audited patterns over custom security for reliability, prioritizing battle-tested code. Implemented non-transferable NFTs to prevent certificate trading, accepting reduced NFT utility. Deferred multi-chain support to focus on Ethereum, planning Polygon/Arbitrum integration for future scaling.",
    "implementationStatus": "Completed (~75%): Core certificate minting, IPFS integration, wallet-based viewing, public verification, batch management, smart contract deployment, and production deployment. Deferred: Multi-chain support (Polygon, Arbitrum), certificate revocation mechanism, advanced verification features, mobile wallet support, and batch minting optimizations.",
    "potentialExpansion": "Vision includes multi-chain deployment (Polygon, Arbitrum) for lower gas costs, certificate revocation mechanism for edge cases, advanced verification with QR codes, and mobile wallet support. Planned scaling through IPFS pinning services, MongoDB sharding for large institutions, and CDN integration for metadata delivery. Enterprise features include institution-specific smart contracts, automated certificate issuance workflows, and comprehensive audit trails.",
    "technologies": [
      {
        "name": "React 19",
        "category": "Frontend",
        "icon": "react"
      },
      {
        "name": "Tailwind CSS",
        "category": "Styling",
        "icon": "tailwind"
      },
      {
        "name": "RainbowKit",
        "category": "Frontend",
        "icon": "web3"
      },
      {
        "name": "Wagmi",
        "category": "Frontend",
        "icon": "web3"
      },
      {
        "name": "ethers.js",
        "category": "Frontend",
        "icon": "ethereum"
      },
      {
        "name": "Node.js",
        "category": "Backend",
        "icon": "nodejs"
      },
      {
        "name": "Express.js",
        "category": "Backend",
        "icon": "express"
      },
      {
        "name": "MongoDB",
        "category": "Database",
        "icon": "mongodb"
      },
      {
        "name": "Mongoose",
        "category": "ODM",
        "icon": "mongoose"
      },
      {
        "name": "Solidity",
        "category": "Blockchain",
        "icon": "solidity"
      },
      {
        "name": "Hardhat",
        "category": "Blockchain",
        "icon": "hardhat"
      },
      {
        "name": "IPFS",
        "category": "Storage",
        "icon": "ipfs"
      }
    ],
    "features": [
      "Secure certificate minting with owner-only access control",
      "IPFS integration for decentralized metadata storage",
      "Wallet-based certificate viewing for students",
      "Public certificate verification using token IDs",
      "Batch management through MongoDB",
      "Clean grayscale UI design",
      "Real-time blockchain state updates",
      "Non-transferable NFTs to prevent certificate trading"
    ],
    "challenges": [
      "Integrating multiple Web3 libraries (RainbowKit, Wagmi, ethers.js v6) with proper async handling",
      "Coordinating frontend, backend, and blockchain interactions seamlessly",
      "Implementing automatic metadata upload and retrieval from IPFS via Pinata API",
      "Resolving Node.js version conflicts and peer dependency issues in production",
      "Fixing ethers.js v6 async signer issues and implementing proper contract interactions",
      "Configuring multi-network support with proper chain switching and provider management",
      "Designing secure smart contracts with OpenZeppelin v5 and ReentrancyGuard protection"
    ],
    "outcomes": [
      "Fully functional Web3 application with all core features implemented and tested",
      "Production deployment on Netlify (frontend), Render (backend), and Sepolia testnet (smart contracts)",
      "Secure smart contract with owner-only minting and ReentrancyGuard protection",
      "Dual storage system with MongoDB for queries, IPFS for metadata, and Blockchain for verification",
      "Comprehensive error handling and loading states for all Web3 interactions",
      "Clean, professional UI with excellent user experience and wallet integration"
    ],
    "metrics": [
      {
        "label": "Smart Contract",
        "value": "ERC721-compliant",
        "description": "OpenZeppelin audited patterns"
      },
      {
        "label": "API Endpoints",
        "value": "5 RESTful",
        "description": "Comprehensive error handling"
      },
      {
        "label": "Security",
        "value": "Owner-only",
        "description": "ReentrancyGuard protection"
      },
      {
        "label": "Storage",
        "value": "Dual system",
        "description": "MongoDB + IPFS + Blockchain"
      }
    ],
    "links": {
      "live": "https://educhainn.netlify.app",
      "github": "https://github.com/Ancel-duke/EduChain"
    },
    "images": {
      "hero": "/assets/projects/EduChain.jpg",
      "before": "/assets/projects/EduChain.jpg",
      "after": "/assets/projects/EduChain.jpg",
      "gallery": [
        "/assets/projects/EduChain.jpg"
      ]
    }
  },
  {
    "id": 11,
    "slug": "ledgerx",
    "title": "LedgerX - Finance Management Platform",
    "subtitle": "Building a comprehensive finance management application with multi-tenant architecture and real-time analytics",
    "role": "Full-Stack Software Engineer",
    "timeline": "3 months",
    "year": "2026",
    "status": "Live",
    "description": "LedgerX is a resilient, multi-tenant finance management platform architected to handle invoice processing, payment tracking, and financial analytics for businesses at scale. The system features hybrid database architecture (PostgreSQL + MongoDB), real-time data synchronization, and comprehensive analytics with complete data isolation across organizations.",
    "problem": "Businesses struggle with manual invoice and payment tracking, leading to errors, delayed payments, and lack of financial visibility. Traditional systems lack real-time updates, multi-tenant support, and comprehensive analytics needed for modern business operations. Organizations require secure, isolated data management with automated workflows, real-time insights, and the ability to scale across multiple teams and departments.",
    "solution": "I architected LedgerX as a modern, full-stack finance management platform with enterprise-grade multi-tenant architecture, hybrid database design, and real-time data synchronization. The platform automates invoice status updates, tracks payments with balance calculations, and provides real-time insights through interactive dashboards. Built with NestJS for modular backend services, Next.js for performant frontend, PostgreSQL for transactional data, and MongoDB for activity logs, ensuring optimal performance and scalability.",
    "impact": "LedgerX enables businesses to manage finances efficiently with automated invoice tracking, real-time payment processing, and comprehensive analytics. The multi-tenant architecture supports multiple organizations with complete data isolation and role-based access control. The platform features 20+ API endpoints, dual-database architecture for optimal performance, 100% TypeScript coverage for type safety, and automatic data refresh intervals (10-30 seconds) for near-real-time updates.",
    "architecture": "LedgerX follows a hybrid database architecture with PostgreSQL (via Prisma ORM) for transactional financial data and MongoDB (via Mongoose) for append-only activity logs. The backend uses NestJS modular architecture with feature-based modules (invoices, payments, clients, organizations). The frontend uses Next.js 14 App Router with TanStack Query for efficient server state management and automatic data refetching. Authentication uses JWT with Passport.js strategies. Multi-tenant isolation is enforced at the database query level, ensuring all operations are scoped to organization IDs. Real-time updates are achieved through TanStack Query's refetch intervals (10-30 seconds) without WebSocket overhead.",
    "isolation": "Multi-tenant isolation is enforced through organization-scoped queries at every API endpoint, preventing cross-organization data access. Database transactions ensure atomic operations for invoice and payment updates. Service isolation is achieved through NestJS modules, separating invoice management, payment processing, and analytics. Error handling is centralized with exception filters, preventing cascading failures. Database connection pooling prevents connection exhaustion. Frontend error boundaries isolate component failures. Activity logging is isolated in MongoDB, preventing impact on transactional PostgreSQL performance.",
    "tradeoffs": "Chose hybrid database architecture (PostgreSQL + MongoDB) over single database for optimal performance: PostgreSQL for ACID transactions, MongoDB for high-volume activity logs. Implemented automatic refresh intervals over WebSockets for simplicity and cost efficiency, trading real-time updates for reduced infrastructure complexity. Selected Prisma ORM for type safety and migrations, trading some flexibility for developer experience. Used TanStack Query over Redux for server state management, prioritizing API integration over complex middleware. Deferred advanced features like payment gateway integration and automated reminders to focus on core financial management.",
    "implementationStatus": "Completed (~75%): Core invoice management, payment processing, client management, multi-tenant architecture, real-time analytics dashboard, activity logging, role-based access control, and mobile-responsive UI. Deferred: Payment gateway integrations (Stripe, PayPal), automated email notifications, PDF invoice generation, advanced reporting, mobile native apps, and third-party accounting software integrations.",
    "potentialExpansion": "Vision includes scaling to 1,000+ organizations through PostgreSQL read replicas, Redis caching for frequently accessed data, and microservices extraction for payment processing and notifications. Planned containerization with Docker and Kubernetes for orchestration. Advanced features include AI-powered cash flow forecasting, automated payment reminders, multi-currency support, and comprehensive audit trails. Enterprise features include SSO integration, advanced permissions, and white-label customization.",
    "technologies": [
      {
        "name": "Next.js 14",
        "category": "Frontend",
        "icon": "nextjs"
      },
      {
        "name": "React 18",
        "category": "Frontend",
        "icon": "react"
      },
      {
        "name": "TypeScript",
        "category": "Language",
        "icon": "typescript"
      },
      {
        "name": "NestJS",
        "category": "Backend",
        "icon": "nestjs"
      },
      {
        "name": "PostgreSQL",
        "category": "Database",
        "icon": "postgresql"
      },
      {
        "name": "Prisma",
        "category": "ORM",
        "icon": "prisma"
      },
      {
        "name": "MongoDB",
        "category": "Database",
        "icon": "mongodb"
      },
      {
        "name": "Mongoose",
        "category": "ODM",
        "icon": "mongoose"
      },
      {
        "name": "JWT",
        "category": "Authentication",
        "icon": "jwt"
      },
      {
        "name": "Passport.js",
        "category": "Authentication",
        "icon": "passport"
      },
      {
        "name": "TanStack Query",
        "category": "State Management",
        "icon": "reactquery"
      },
      {
        "name": "Recharts",
        "category": "Visualization",
        "icon": "recharts"
      },
      {
        "name": "Tailwind CSS",
        "category": "Styling",
        "icon": "tailwind"
      },
      {
        "name": "Axios",
        "category": "HTTP Client",
        "icon": "axios"
      }
    ],
    "features": [
      "Invoice management with detailed line items and automatic status updates",
      "Payment processing with automatic invoice status updates and balance tracking",
      "Client management with organization-scoped data isolation",
      "Real-time analytics dashboard with interactive charts and metrics",
      "Activity logging with complete audit trail stored in MongoDB",
      "Multi-tenant architecture with secure data isolation and role-based access control",
      "Responsive design for desktop and mobile devices",
      "Automatic data synchronization with refresh intervals (10-30 seconds)"
    ],
    "challenges": [
      "Implementing multi-tenant data isolation with organization-scoped queries across all endpoints",
      "Configuring automatic data refresh intervals (10-30s) without overwhelming the server using TanStack Query",
      "Building automatic invoice status updates based on payment processing with balance tracking",
      "Maintaining end-to-end TypeScript type safety across API boundaries with shared types",
      "Automating Prisma migrations in production environment without shell access on Render",
      "Properly configuring CORS for deployed frontend (Netlify) and backend (Render)",
      "Designing dual-database architecture with PostgreSQL for transactions and MongoDB for activity logs"
    ],
    "outcomes": [
      "Production-ready full-stack finance management application with 20+ API endpoints",
      "Multi-tenant architecture with complete data isolation and organization-scoped queries",
      "Real-time data synchronization with automatic refresh intervals (10-30 seconds)",
      "Comprehensive analytics and reporting capabilities with Recharts visualizations",
      "Secure authentication and authorization system with JWT and Passport.js",
      "Mobile-responsive design with excellent UX across all devices",
      "100% TypeScript coverage ensuring type safety throughout the application"
    ],
    "metrics": [
      {
        "label": "Data Refresh",
        "value": "10-30s",
        "description": "Automatic refresh intervals"
      },
      {
        "label": "Databases",
        "value": "2",
        "description": "PostgreSQL + MongoDB architecture"
      },
      {
        "label": "API Endpoints",
        "value": "20+",
        "description": "RESTful API with comprehensive features"
      },
      {
        "label": "Type Safety",
        "value": "100%",
        "description": "End-to-end TypeScript coverage"
      }
    ],
    "links": {
      "live": "https://ledgerxx.netlify.app/auth/login",
      "github": "https://github.com/Ancel-duke/LedgerX"
    },
    "images": {
      "hero": "/assets/projects/LedgerX.jpg",
      "before": "/assets/projects/LedgerX.jpg",
      "after": "/assets/projects/LedgerX2.jpg",
      "gallery": [
        "/assets/projects/LedgerX.jpg",
        "/assets/projects/LedgerX2.jpg"
      ]
    }
  },
  {
    "id": 13,
    "slug": "opsflow",
    "title": "OpsFlow - Incident & Operations Management Platform",
    "subtitle": "Building a production-ready incident and workflow management platform for engineering teams",
    "role": "Full-Stack Software Engineer",
    "timeline": "4 months",
    "year": "2026",
    "status": "Completed",
    "description": "OpsFlow is a production-ready incident and operations management platform architected for engineering teams, combining incident response, workflow management, task coordination, and knowledge sharing into a single secure team-based system. The platform features dual-database architecture (PostgreSQL + MongoDB), real-time WebSocket updates, and team-based multi-tenancy with 50+ API endpoints.",
    "problem": "Engineering and operations teams rely on multiple disconnected tools to manage incidents, workflows, and documentation, leading to poor incident visibility, delayed response times, fragmented operational knowledge, weak accountability, and difficulty scaling workflows as teams grow. Existing solutions are either too expensive or lack the integration needed for unified operations management.",
    "solution": "I architected OpsFlow as a unified operations platform enabling teams to manage the full incident lifecycle with SLA tracking, coordinate response workflows and tasks in real-time, maintain a searchable team-scoped knowledge base, enforce role-based and team-based access control, and monitor operational health through a centralized dashboard. The system uses dual-database architecture (PostgreSQL for transactions, MongoDB for event logs) and WebSocket-powered real-time updates without requiring paid infrastructure.",
    "impact": "Production-ready system with 50+ API endpoints and real-time incident updates without paid infrastructure. Secure team-based multi-tenant architecture with complete data isolation, fully documented setup and deployment guides, and responsive UI across mobile, tablet, and desktop. Demonstrates enterprise-grade backend and system design skills with real-world SaaS architecture, security awareness, and proven ability to build production-ready systems under infrastructure constraints.",
    "architecture": "OpsFlow follows a dual-database architecture: PostgreSQL (via Prisma ORM) for structured relational data (incidents, workflows, teams) and MongoDB for append-only event logs and timelines. The backend uses NestJS modular architecture with feature-based modules. The frontend uses Next.js 14 with TypeScript for type safety. Real-time updates are handled through WebSocket connections (Socket.IO) without background workers, computing SLA calculations and breach detection on-demand during API requests. Multi-tenant isolation is enforced at the database query level with team-scoped filtering.",
    "isolation": "Service isolation is achieved through NestJS modules, separating incident management, workflow coordination, and knowledge base. Database operations use PostgreSQL transactions for atomic updates and MongoDB for isolated event logging. WebSocket handlers are isolated from API routes, preventing real-time failures from affecting REST endpoints. Error handling is centralized with exception filters, preventing cascading failures. Team-level data isolation is enforced at every database query, ensuring complete multi-tenant security. Frontend error boundaries isolate component failures, maintaining application stability.",
    "tradeoffs": "Chose dual-database architecture (PostgreSQL + MongoDB) over single database for optimal performance: PostgreSQL for ACID transactions, MongoDB for high-volume event logs. Implemented on-demand SLA calculations over scheduled jobs for free-tier optimization, trading some efficiency for infrastructure cost savings. Used WebSockets for real-time updates without Redis pub-sub, accepting single-server limitations for simplicity. Selected Prisma ORM for type safety and migrations, trading some flexibility for developer experience. Deferred advanced features like automated incident routing and advanced analytics to focus on core operations management.",
    "implementationStatus": "Completed (~75%): Core incident management, workflow coordination, knowledge base, team-based multi-tenancy, role-based access control, real-time WebSocket updates, SLA tracking, and audit trails. Deferred: Advanced analytics and reporting, integration with external monitoring tools, mobile native apps, enhanced notification system, and automated incident response workflows.",
    "potentialExpansion": "Vision includes scaling to 1,000+ teams through PostgreSQL read replicas, Redis pub-sub for WebSocket message distribution, and microservices extraction for analytics and notifications. Planned containerization with Docker and Kubernetes for orchestration. Advanced features include AI-powered incident prediction, automated response workflows, integration with PagerDuty/Slack, and comprehensive operational dashboards. Enterprise features include SSO integration, advanced permissions, and white-label customization.",
    "technologies": [
      {
        "name": "NestJS",
        "category": "Backend",
        "icon": "nestjs"
      },
      {
        "name": "Next.js 14",
        "category": "Frontend",
        "icon": "nextjs"
      },
      {
        "name": "TypeScript",
        "category": "Language",
        "icon": "typescript"
      },
      {
        "name": "PostgreSQL",
        "category": "Database",
        "icon": "postgresql"
      },
      {
        "name": "MongoDB",
        "category": "Database",
        "icon": "mongodb"
      },
      {
        "name": "Prisma",
        "category": "ORM",
        "icon": "prisma"
      },
      {
        "name": "WebSockets",
        "category": "Real-time",
        "icon": "socketio"
      },
      {
        "name": "JWT",
        "category": "Authentication",
        "icon": "jwt"
      },
      {
        "name": "RBAC",
        "category": "Security",
        "icon": "security"
      },
      {
        "name": "Tailwind CSS",
        "category": "Styling",
        "icon": "tailwind"
      }
    ],
    "features": [
      "Incident Management with enforced lifecycle states and SLA breach detection",
      "Real-time updates using WebSockets for live incident activity",
      "Workflow and task management scoped to teams",
      "Knowledge base with markdown support, versioning and search",
      "Team-based multi-tenancy with strict data isolation",
      "Role-based access control (Admin, Manager, Engineer and Viewer)",
      "Audit trails and timelines for all incident activity",
      "Postmortem documentation linked to resolved incidents"
    ],
    "challenges": [
      "Dual-database strategy separating transactional data from event logs",
      "Multi-tenant security model with team-level data isolation",
      "Real-time incident updates without background workers",
      "SLA calculations with breach detection and health metrics",
      "Production-grade error handling, validation, and logging",
      "Free-tier optimized infrastructure without sacrificing reliability"
    ],
    "outcomes": [
      "Production-ready system with 50+ API endpoints",
      "Real-time incident updates without paid infrastructure",
      "Secure, team-based multi-tenant architecture",
      "Fully documented setup and deployment guides",
      "Responsive UI across mobile, tablet, and desktop"
    ],
    "metrics": [
      {
        "label": "API Endpoints",
        "value": "50+",
        "description": "RESTful API with comprehensive features"
      },
      {
        "label": "Databases",
        "value": "2",
        "description": "PostgreSQL + MongoDB architecture"
      },
      {
        "label": "Real-time Updates",
        "value": "WebSockets",
        "description": "Live incident activity without polling"
      },
      {
        "label": "Access Control",
        "value": "RBAC + Teams",
        "description": "Role and team-based permissions"
      }
    ],
    "links": {
      "live": "",
      "github": "https://github.com/Ancel-duke/OpsFlow"
    },
    "images": {
      "hero": "/assets/projects/opsflow.jpg",
      "before": "/assets/projects/opsflow.jpg",
      "after": "/assets/projects/opsflow.jpg",
      "gallery": [
        "/assets/projects/opsflow.jpg"
      ]
    }
  },
  {
    "id": 14,
    "slug": "signflow",
    "title": "SignFlow - Real-Time Assistive Tech Simulation for Sign Language",
    "subtitle": "Building a high-fidelity assistive technology simulation for real-time sign language translation",
    "role": "Full-Stack Software Engineer",
    "timeline": "4 months",
    "year": "2026",
    "status": "Completed",
    "description": "SignFlow is a high-fidelity assistive technology platform architected for real-time sign language translation, exploring the architectural requirements for scaling accessibility platforms. The system features WebSocket-powered streaming, 3D avatar simulation with natural variation, and accessibility-first design with WCAG compliance, demonstrating production-grade architecture for specialized user bases.",
    "problem": "Current text-to-sign demonstrations suffer from robotic user experience with repetition, static nature, latency issues, and UX gaps. Identical animations play for every word without variation, there's a lack of timing, facial expression, or prosody, poor real-time feedback loops, and negligible consideration for accessibility. For assistive technology to be trusted by the Deaf and Hard-of-Hearing community, naturalness and responsiveness are as critical as linguistic correctness.",
    "solution": "I architected SignFlow as a sophisticated assistive technology platform with dynamic logic for per-word and phrase-based animation sequences, live streaming via WebSocket-powered translation for near-zero latency, responsive interface with high-fidelity 3D avatar that reacts to user input, and accessibility-first design with UI built specifically for inclusive user experiences. By applying subtle variations to repeated inputs, SignFlow creates the illusion of a living interpreter rather than a looped animation, demonstrating production-grade architecture for specialized user bases.",
    "impact": "Fully implemented assistive technology prototype demonstrating real-time system design using WebSockets, scalable cloud architecture with MongoDB Atlas, intentional UX for specialized user bases, and product-level thinking bridging coding projects and viable market solutions. The platform features high-fidelity 3D avatar simulation, natural variation in animations, comprehensive analytics dashboard, and full WCAG accessibility compliance, showcasing enterprise-grade architecture for accessibility platforms.",
    "architecture": "SignFlow follows a real-time streaming architecture: React frontend with Three.js (React Three Fiber) for 3D avatar rendering, Node.js/Express backend for translation processing, MongoDB Atlas for cloud-hosted data with indexed collections, and WebSocket connections for near-zero latency streaming. Animation pools store multiple variations per word/phrase, with seed-based selection for natural variation. The architecture separates 3D rendering from translation logic, ensuring smooth performance. Analytics are computed on-demand using MongoDB aggregation pipelines.",
    "isolation": "Service isolation is achieved through separate layers: 3D rendering is isolated from translation processing, preventing rendering failures from affecting translation. WebSocket connections are handled independently from REST API routes. Animation pools are cached client-side, reducing server load. Error handling is centralized with custom exception handlers, preventing cascading failures. Database operations use MongoDB transactions for atomic updates. Frontend error boundaries isolate 3D rendering failures, maintaining application stability. Accessibility features are isolated in dedicated components, ensuring WCAG compliance.",
    "tradeoffs": "Chose WebSocket streaming over REST polling for near-zero latency, trading some complexity for real-time responsiveness. Selected Three.js over simpler 2D animations for immersive experience, accepting higher rendering complexity. Implemented animation pools over single animations for natural variation, trading storage for believability. Used MongoDB Atlas over self-hosted for cloud scalability, accepting vendor dependency. Deferred advanced features like voice input and video recording to focus on core translation experience, ensuring faster time-to-market.",
    "implementationStatus": "Completed (~70%): Core real-time translation engine, 3D avatar simulation, natural animation variation, WebSocket streaming, analytics dashboard, accessibility compliance (WCAG), and responsive UI. Deferred: Voice input support, video recording, multiple avatar options, sign language learning modules, community features, and mobile native apps.",
    "potentialExpansion": "Vision includes scaling to 10,000+ concurrent users through WebSocket load balancing, Redis for session management, and CDN integration for 3D assets. Planned containerization with Docker for consistent deployments. Advanced features include AI-powered sign recognition, multiple avatar personalization, sign language learning modules, and community sharing capabilities. Enterprise features include API access for third-party integrations, white-label customization, and comprehensive analytics dashboards.",
    "technologies": [
      {
        "name": "React",
        "category": "Frontend",
        "icon": "react"
      },
      {
        "name": "Node.js",
        "category": "Backend",
        "icon": "nodejs"
      },
      {
        "name": "Express",
        "category": "Backend",
        "icon": "express"
      },
      {
        "name": "MongoDB",
        "category": "Database",
        "icon": "mongodb"
      },
      {
        "name": "WebSockets",
        "category": "Real-time",
        "icon": "socketio"
      },
      {
        "name": "Three.js",
        "category": "3D Graphics",
        "icon": "threejs"
      },
      {
        "name": "React Three Fiber",
        "category": "3D Graphics",
        "icon": "react"
      },
      {
        "name": "JWT",
        "category": "Authentication",
        "icon": "jwt"
      },
      {
        "name": "Recharts",
        "category": "Visualization",
        "icon": "recharts"
      },
      {
        "name": "Framer Motion",
        "category": "Animation",
        "icon": "framer"
      }
    ],
    "features": [
      "Real-time translation engine with streaming input via WebSockets",
      "Believable avatar simulation with phrase mapping and animation pooling",
      "Natural variation with variable animation speeds and micro-expressions",
      "Immersive and accessible UI with split-screen design",
      "Analytics and insights dashboard with session metrics",
      "Full accessibility support with ARIA compliance and keyboard navigation",
      "High-contrast modes and adjustable font sizes",
      "Interactive timeline with hover previews and AI-powered suggestions"
    ],
    "challenges": [
      "Implementing real-time WebSocket streaming for near-zero latency translation",
      "Creating natural variation in animations to prevent robotic movement",
      "Building high-fidelity 3D avatar with micro-expressions and natural body movements",
      "Designing accessible UI for specialized user bases with full ARIA compliance",
      "Optimizing animation performance for smooth real-time rendering",
      "Implementing phrase detection and special animation sequences"
    ],
    "outcomes": [
      "Fully functional assistive technology prototype with production-grade architecture",
      "Real-time translation system with WebSocket-powered streaming",
      "High-fidelity 3D avatar with natural variation and micro-expressions",
      "Comprehensive analytics dashboard with interactive charts and user insights",
      "Full accessibility compliance with WCAG standards",
      "Scalable cloud architecture with MongoDB Atlas"
    ],
    "metrics": [
      {
        "label": "Real-time Latency",
        "value": "Near-zero",
        "description": "WebSocket-powered streaming"
      },
      {
        "label": "Animation Variations",
        "value": "Multiple",
        "description": "Per-word animation pools with natural variation"
      },
      {
        "label": "Accessibility",
        "value": "WCAG Compliant",
        "description": "Full ARIA support and keyboard navigation"
      },
      {
        "label": "Database",
        "value": "MongoDB Atlas",
        "description": "Cloud-hosted with indexed collections"
      }
    ],
    "links": {
      "live": "",
      "github": "https://github.com/Ancel-duke/SignFlow"
    },
    "images": {
      "hero": "/assets/projects/signflow1.jpg",
      "before": "/assets/projects/signflow1.jpg",
      "after": "/assets/projects/signflow2.jpg",
      "gallery": [
        "/assets/projects/signflow1.jpg",
        "/assets/projects/signflow2.jpg",
        "/assets/projects/flow.jpg",
        "/assets/projects/flow2.jpg"
      ]
    }
  },
  {
    "id": 15,
    "slug": "nestfi",
    "title": "NestFi  Resilient Financial Coordination Platform",
    "subtitle": "Correctness-first finance with hybrid storage, M-Pesa callbacks, and failure-aware design",
    "role": "Full-Stack Software Engineer",
    "timeline": "Ongoing",
    "year": "2026",
    "status": "In Progress",
    "description": "NestFi is a stateless financial platform designed to handle real-world constraints such as unreliable networks, asynchronous M-Pesa payments, and partial system failures. It integrates mobile and web clients with a single NestJS backend and a hybrid database architecture, prioritizing correctness, resilience, and production-grade design over feature bloat.",
    "problem": "Building a finance system isnt CRUD  its correctness under failure. NestFi must remain predictable when payment providers are asynchronous, callbacks are delayed or duplicated, caches fail, logs are temporarily unavailable, and network conditions are unreliable. The core challenge is fault isolation and ledger correctness across multiple storage models and external integrations.",
    "solution": "NestFi is built around deliberate architectural principles: service isolation (API, PostgreSQL, MongoDB, Redis, external providers), a stateless backend (JWT auth, restart-safe, horizontally scalable), and hybrid data modeling (PostgreSQL for ledgers and wallets, MongoDB for events/logs/payment callbacks, Redis for caching/rate limits/temporary state). External payment flows (M-Pesa Daraja) are treated as asynchronous and idempotent, with timeouts, retries with backoff, circuit breakers, graceful degradation of non-critical features, and health checks for observability. Callback and notification handling is supported via Cloudflare Workers.",
    "impact": "NestFi demonstrates capstone-level engineering: hybrid databases chosen by data guarantees, explicit failure modes and containment, and real payment infrastructure integration. The platform is designed under the assumption that failures are normal  not exceptional  and that core financial correctness must remain intact even when non-critical components degrade.",
    "isolation": "Core responsibilities run independently: the backend orchestrates logic and is safe to restart; PostgreSQL remains the financial source of truth with no silent corruption; MongoDB (events/logs) is optional during failure; Redis is a performance layer that can be bypassed; M-Pesa callbacks are processed in an idempotent, delay-tolerant manner. Security and network isolation are enforced via Docker and minimal exposed ports, with TLS at the edge via Cloudflare.",
    "tradeoffs": "Hybrid storage increases operational complexity, but it matches real financial system constraints: strong correctness guarantees in PostgreSQL for ledgers, flexible event/log storage in MongoDB, and low-latency ephemeral state in Redis. The design prioritizes correctness, resilience, and auditability over feature count, intentionally deferring non-critical UI polish and optional modules.",
    "implementationStatus": "Current status (~75%): Core architecture, hybrid data model, and key integrations are implemented. Remaining work is frontend polish, an optional KYC module, and operational refinements. Documentation is maintained alongside the codebase, and the Dockerized workflow supports deterministic builds.",
    "potentialExpansion": "Frontend polish and UX refinement across mobile and web. Optional KYC module and expanded compliance workflows. Operational refinements: deeper observability, trace correlation across callbacks, runbooks, and replay tooling for event/callback recovery.",
    "technologies": [
      { "name": "NestJS", "category": "Backend", "icon": "nestjs" },
      { "name": "TypeScript", "category": "Language", "icon": "typescript" },
      { "name": "PostgreSQL", "category": "Database", "icon": "postgresql" },
      { "name": "MongoDB", "category": "Database", "icon": "mongodb" },
      { "name": "Redis", "category": "Cache", "icon": "redis" },
      { "name": "Docker", "category": "DevOps", "icon": "docker" },
      { "name": "Cloudflare Workers", "category": "Edge", "icon": "cloudflare" },
      { "name": "M-Pesa Daraja", "category": "Integration", "icon": "api" },
      { "name": "JWT", "category": "Authentication", "icon": "jwt" },
      { "name": "React Native", "category": "Mobile", "icon": "react" },
      { "name": "Next.js", "category": "Frontend", "icon": "nextjs" }
    ],
    "features": [
      "Wallets, transactions, and automated savings flows",
      "Stateless NestJS backend (horizontally scalable, restart-safe)",
      "Hybrid storage: PostgreSQL (ledgers), MongoDB (events/logs/callbacks), Redis (ephemeral state)",
      "M-Pesa Daraja integration with asynchronous callback handling",
      "Resilience patterns: timeouts, retries with backoff, circuit breakers, graceful degradation",
      "Observability: health checks and failure containment",
      "Security-first baseline: JWT auth, validation, rate limiting, callback IP allowlisting, TLS at the edge"
    ],
    "challenges": [
      "Designing idempotent, delay-tolerant callback processing for external payment providers",
      "Preventing cascading failures across cache/log/payment dependencies",
      "Choosing data stores by guarantees (ACID ledgers vs event logs vs ephemeral state)",
      "Hardening service isolation with Docker networks and minimal exposed ports",
      "Making builds deterministic and reproducible across environments"
    ],
    "outcomes": [
      "Correctness-first architecture designed for partial failures and unreliable networks",
      "Hybrid database model aligned with real financial constraints",
      "Clear isolation boundaries so non-critical components can fail safely",
      "Deterministic Dockerized infrastructure suitable for production hardening"
    ],
    "metrics": [
      { "label": "Completion", "value": "~75%", "description": "MVP complete with core architecture + integrations; hardening and polish remain" },
      { "label": "Datastores", "value": "3", "description": "PostgreSQL + MongoDB + Redis hybrid model" },
      { "label": "Payment Integration", "value": "M-Pesa", "description": "Asynchronous callbacks, idempotent processing" },
      { "label": "Resilience", "value": "Circuit breakers", "description": "Timeouts + safe retries + graceful degradation" }
    ],
    "links": {
      "live": "",
      "github": "https://github.com/Ancel-duke/NestFi",
      "docs": "https://github.com/Ancel-duke/NestFi/blob/main/docs/ARCHITECTURE.md"
    },
    "images": {
      "hero": "/assets/projects/nestfi.jpg",
      "before": "/assets/projects/nestfi.jpg",
      "after": "/assets/projects/nestfi.jpg",
      "gallery": [
        "/assets/projects/nestfi.jpg"
      ]
    }
  },
  {
    "id": 16,
    "slug": "edumanage",
    "title": "EduManage  Multi-Tenant School Management SaaS",
    "subtitle": "Streamlining administration, enrollment, and reporting for schools",
    "role": "Full-Stack Software Engineer",
    "timeline": "5 months",
    "year": "2025",
    "status": "Completed",
    "description": "A comprehensive educational management system designed to streamline administrative tasks, student enrollment, and academic reporting.",
    "problem": "Schools often rely on fragmented tooling (spreadsheets, paper records, disconnected apps) for enrollment, administration, and reporting. This creates duplicate data entry, inconsistent records, and slow reporting cyclesespecially when multiple staff roles require different access levels.",
    "solution": "EduManage centralizes core school operations into a single system with clear role boundaries. The platform focuses on predictable workflows for student enrollment, administrative management, and academic reporting, with structured access control and a backend designed to handle growth and operational complexity.",
    "impact": "Delivered a unified school operations platform that reduces administrative overhead, improves record consistency, and enables faster, more reliable reporting. The system is structured for maintainability, with clear module boundaries that support incremental expansion over time.",
    "isolation": "Tenant isolation is enforced at the data access layer so every request is scoped to an institution. Auth and authorization are stateless (JWT) and hierarchical (RBAC), and real-time event delivery is isolated through Socket.io channels to prevent cross-tenant leakage. The system is built to degrade gracefully when non-critical subsystems are impaired.",
    "tradeoffs": "EduManage ships at ~85% to reflect real-world constraints. Advanced rate limiting, deep automated testing, and caching are intentionally deferred in favor of delivering a stable, well-structured MVP with strong tenant and authorization boundaries.",
    "implementationStatus": "Status: MVP Complete (~85%). Core multi-tenancy, RBAC, and real-time events are implemented. Deferred: advanced rate limiting, deeper automated test coverage, and advanced caching layers.",
    "potentialExpansion": "Add advanced caching for hot reads, rate limiting and abuse protection, deeper automated testing (unit + integration), audit trails for sensitive operations, and expanded real-time notification pipelines.",
    "technologies": [
      { "name": "NestJS", "category": "Backend", "icon": "nestjs" },
      { "name": "Express.js", "category": "Backend", "icon": "express" },
      { "name": "MongoDB", "category": "Database", "icon": "mongodb" },
      { "name": "JWT", "category": "Authentication", "icon": "jwt" },
      { "name": "RBAC", "category": "Security", "icon": "security" },
      { "name": "Socket.io", "category": "Real-time", "icon": "socketio" },
      { "name": "TypeScript", "category": "Language", "icon": "typescript" },
      { "name": "Docker", "category": "DevOps", "icon": "docker" }
    ],
    "features": [
      "Multi-tenant backend with tenant-scoped data access",
      "JWT-based stateless authentication",
      "Hierarchical RBAC for complex school permissions",
      "Real-time notifications and updates via Socket.io",
      "Failure-aware design with graceful degradation",
      "Dockerized development and deployment workflow"
    ],
    "challenges": [
      "Enforcing tenant isolation across all access paths",
      "Keeping authorization logic predictable as roles and permissions expand",
      "Designing real-time events without cross-tenant leakage",
      "Modeling flexible academic domain entities in MongoDB",
      "Building for partial failures without degrading core workflows"
    ],
    "outcomes": [
      "MVP complete with production-ready tenant and authorization boundaries",
      "Real-time operational workflows supported via event-driven updates",
      "Architecture documented and maintained in GitHub docs"
    ],
    "metrics": [
      { "label": "Status", "value": "~85%", "description": "MVP complete; hardening and optimizations deferred" },
      { "label": "Multi-Tenancy", "value": "Tenant-scoped", "description": "Institution isolation enforced at data layer" },
      { "label": "AuthZ", "value": "Hierarchical RBAC", "description": "Role and permission boundaries designed to scale" },
      { "label": "Real-time", "value": "Socket.io", "description": "Notifications and operational updates" }
    ],
    "links": {
      "live": "",
      "github": "https://github.com/Ancel-duke/edumanage",
      "docs": "https://github.com/Ancel-duke/edumanage/blob/main/docs/ARCHITECTURE.md"
    },
    "images": {
      "hero": "/assets/projects/edumanage.jpg",
      "before": "/assets/projects/edumanage.jpg",
      "after": "/assets/projects/edumanage.jpg",
      "gallery": [
        "/assets/projects/edumanage.jpg"
      ]
    }
  },
  {
    "id": 17,
    "slug": "aegis",
    "title": "Aegis  Self-Healing Infrastructure with Policy and AI",
    "subtitle": "Intelligent monitoring, policy-driven decisions, and safe Kubernetes automation",
    "role": "Full-Stack Software Engineer",
    "timeline": "Ongoing",
    "year": "2026",
    "status": "Live",
    "description": "Aegis monitors infrastructure behavior, detects anomalies using AI, evaluates security policies, and executes tightly controlled remediation actions. It is built with strict isolation boundaries, auditability, and failure-aware automation to avoid unsafe self-healing.",
    "problem": "Modern infrastructure fails silently. Teams only react after damage is done, and automation often introduces more risk than it removes. Monitoring tools detect issues but don't act; automation tools act but aren't safe; security and operations are disconnected; AI systems make decisions without accountability.",
    "solution": "Aegis introduces four controlled layers: Observation (metrics, logs, traces, events), Intelligence (AI-driven anomaly detection), Policy (explicit, auditable rules for what is allowed), and Execution (isolated, signed, least-privilege actions). Automation is only allowed when policy, identity, and safety constraints all pass.",
    "impact": "Aegis guarantees: no unaudited actions, no blind AI execution, no privilege escalation, no silent failures. Security highlights include JWT + RBAC, HMAC-signed executor actions, namespace allowlisting, immutable audit logs, and default-deny network policies. The platform is designed so an ethical hacker can reason about what cannot happen.",
    "architecture": "Core services: Backend (NestJS)  Auth, policies, audit, APIs; AI Engine (FastAPI)  Anomaly detection and recommendations; Executor Service  Secure Kubernetes actions; Frontend (Next.js)  Observability and control plane UI. Infrastructure: Docker and Kubernetes, PostgreSQL and Redis, Prometheus, Grafana, Loki, Tempo, CI/CD with security scanning, Cloudflare (WAF, webhook protection). Every service is isolated, auditable, and deployable independently.",
    "isolation": "The AI detects anomalies, assigns severity, and recommends actionsbut cannot execute actions directly, override policies, or bypass audit logging. AI informs decisions; policy authorizes actions; humans retain control. Self-healing means restarting unhealthy pods, scaling deployments safely, rolling back bad releases, and temporarily isolating services. Explicitly not supported: arbitrary command execution, destructive actions, unbounded automation loops.",
    "tradeoffs": "Implemented (~95%): Backend APIs and security, AI anomaly detection, executor with Kubernetes RBAC, full observability stack, production-ready frontend, Docker and Kubernetes manifests, CI/CD with rollback. Not yet implemented: mTLS between services, WebSocket backend, full E2E test suite, AI model persistence, external security audit. Known gaps are documented, intentional, and scoped.",
    "implementationStatus": "Implemented (~95%): Backend APIs and security, AI anomaly detection, executor with Kubernetes RBAC, full observability stack, production-ready frontend, Docker and Kubernetes manifests, CI/CD with rollback. Not yet: mTLS, WebSocket backend, full E2E test suite, AI model persistence, external security audit.",
    "potentialExpansion": "Architecture avoids unsafe automation, prioritizes auditability, separates decision from execution, and scales from single cluster to multi-cluster. Matches real production failure modes. Aegis reflects how I think about production systems: assume failure, design for abuse, automate carefully, and leave a trail of evidence for every decision.",
    "technologies": [
      { "name": "NestJS", "category": "Backend", "icon": "nestjs" },
      { "name": "FastAPI", "category": "Backend", "icon": "python" },
      { "name": "Next.js", "category": "Frontend", "icon": "nextjs" },
      { "name": "PostgreSQL", "category": "Database", "icon": "postgresql" },
      { "name": "Redis", "category": "Cache", "icon": "redis" },
      { "name": "Kubernetes", "category": "DevOps", "icon": "kubernetes" },
      { "name": "Docker", "category": "DevOps", "icon": "docker" },
      { "name": "Prometheus", "category": "Observability", "icon": "prometheus" },
      { "name": "Grafana", "category": "Observability", "icon": "grafana" },
      { "name": "JWT", "category": "Authentication", "icon": "jwt" },
      { "name": "TypeScript", "category": "Language", "icon": "typescript" },
      { "name": "Python", "category": "Language", "icon": "python" }
    ],
    "features": [
      "Policy-driven access control and self-healing decisions",
      "ML-based anomaly and failure detection (AI engine)",
      "Safe Kubernetes operations (restart, scale, rollback)",
      "HMAC-signed executor actions and namespace allowlisting",
      "Immutable audit logs and default-deny network policies",
      "Full observability stack (Prometheus, Grafana, Loki, Tempo)",
      "Production-ready Next.js dashboard and control plane UI"
    ],
    "challenges": [
      "Keeping AI recommendations strictly advisoryno direct execution",
      "Enforcing policy evaluation and audit for every action",
      "Isolating executor with minimal Kubernetes RBAC",
      "Designing for failure and partial outages without unsafe automation"
    ],
    "outcomes": [
      "No unaudited actions; no blind AI execution; no privilege escalation",
      "Self-healing within policy: pod restart, scale, rollback only when allowed",
      "Documented architecture and honest status (implemented vs not yet)",
      "Production mindset: assume failure, design for abuse, automate carefully"
    ],
    "metrics": [
      { "label": "Status", "value": "~95%", "description": "Backend, AI engine, executor, frontend, observability complete" },
      { "label": "Security", "value": "Policy + HMAC", "description": "Every action policy-evaluated and signed" },
      { "label": "AI Role", "value": "Recommend only", "description": "AI informs; policy authorizes; humans control" },
      { "label": "Audit", "value": "Immutable", "description": "Trail of evidence for every decision" }
    ],
    "links": {
      "live": "",
      "github": "https://github.com/Ancel-duke/Aegis",
      "docs": "https://github.com/Ancel-duke/Aegis/blob/main/ARCHITECTURE.md"
    },
    "images": {
      "hero": "/assets/projects/aegis.jpg",
      "before": "/assets/projects/aegis.jpg",
      "after": "/assets/projects/aegis.jpg",
      "gallery": [
        "/assets/projects/aegis.jpg"
      ]
    }
  }
]

